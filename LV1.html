<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Responsive Platformer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
    #gameCanvas {
      display: block;
      background: #87CEEB;
      width: 100%;
      height: 100%;
    }
    #overlay {
      position: fixed;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      font-size: min(5vw, 24px);
    }
    #restartButton {
      padding: 1.5vh 3vw;
      font-size: min(4vw, 20px);
      margin-top: 2vh;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <h1>You died</h1>
    <button id="restartButton">Restart</button>
  </div>
  <canvas id="gameCanvas"></canvas>

  <script>
    // Initialize canvas and scaling
    const canvas = document.getElementById('gameCanvas')
    const ctx = canvas.getContext('2d')
    const baseWidth = 800
    const baseHeight = 400
    let scaleRatio = 1

    // Screen adjustment system
    const resizeCanvas = () => {
      const widthRatio = window.innerWidth / baseWidth
      const heightRatio = window.innerHeight / baseHeight
      scaleRatio = Math.min(widthRatio, heightRatio)
      
      canvas.width = baseWidth * scaleRatio
      canvas.height = baseHeight * scaleRatio
    }

    // Game constants
    const GRAVITY = 0.5 * scaleRatio
    const FRICTION = 0.85
    const LEVEL_END_X = 5000
    let cameraX = 0
    let isDead = false

    // Player class with modern JS features
    class Player {
      constructor() {
        this.baseWidth = 40
        this.baseHeight = 60
        this.x = 50
        this.y = 50
        this.velocityX = 0
        this.velocityY = 0
        this.speed = 15 * scaleRatio
        this.onGround = false
        this.jumpsRemaining = 2
      }

      get width() {
        return this.baseWidth * scaleRatio
      }

      get height() {
        return this.baseHeight * scaleRatio
      }

      update(keys) {
        if (isDead) return

        // Horizontal movement
        if (keys.ArrowRight) this.velocityX += 0.5 * scaleRatio
        if (keys.ArrowLeft) this.velocityX -= 0.5 * scaleRatio
        
        this.velocityX *= FRICTION
        this.velocityX = Math.max(-this.speed, Math.min(this.speed, this.velocityX))

        // Double jump implementation
        if (keys.ArrowUp) {
          if (this.onGround) {
            this.velocityY = -12 * scaleRatio
            this.onGround = false
            this.jumpsRemaining = 1
          } else if (this.jumpsRemaining > 0) {
            this.velocityY = -12 * scaleRatio
            this.jumpsRemaining--
          }
        }

        // Apply gravity
        this.velocityY += GRAVITY
        this.x += this.velocityX
        this.y += this.velocityY
        this.x = Math.max(0, Math.min(LEVEL_END_X - this.width, this.x))
      }
    }

    // Initialize game objects
    const player = new Player()
    let blocks = []
    let enemies = []

    // Platform generation using array methods
    const generatePlatforms = () => {
      const floorY = canvas.height - 50 * scaleRatio
      const platformData = [
        { x: 0, y: floorY, width: 300 },
        { x: 300, y: floorY - 100, width: 200 },
        { x: 500, y: floorY - 50, width: 150 },
        { x: LEVEL_END_X - 400, y: floorY, width: 200 }
      ]

      return platformData.map(platform => ({
        ...platform,
        height: 20 * scaleRatio,
        width: platform.width * scaleRatio
      }))
    }

    // Enemy generation using array methods
    const generateEnemies = (platforms) => {
      return platforms.slice(1)
        .map(platform => (Math.random() < 0.3 ? {
          x: platform.x + platform.width/2 - 16 * scaleRatio,
          y: platform.y - 32 * scaleRatio,
          width: 32 * scaleRatio,
          height: 32 * scaleRatio
        } : null))
        .filter(Boolean)
    }

    // Collision detection using modern JS
    const checkCollisions = () => {
      // Platform collisions
      player.onGround = false
      blocks.forEach(block => {
        if (player.x < block.x + block.width &&
            player.x + player.width > block.x &&
            player.y + player.height > block.y &&
            player.y < block.y + block.height) {
          
          if (player.velocityY > 0) {
            player.y = block.y - player.height
            player.velocityY = 0
            player.onGround = true
            player.jumpsRemaining = 2
          }
        }
      })

      // Enemy collisions
      enemies.forEach(enemy => {
        if (player.x < enemy.x + enemy.width &&
            player.x + player.width > enemy.x &&
            player.y < enemy.y + enemy.height &&
            player.y + player.height > enemy.y) {
          handleDeath()
        }
      })
    }

    // Game initialization
    const initializeGame = () => {
      blocks = generatePlatforms()
      enemies = generateEnemies(blocks)
      player.x = blocks[0].x + blocks[0].width/2 - player.width/2
      player.y = blocks[0].y - player.height
      cameraX = 0
      isDead = false
    }

    // Game loop using requestAnimationFrame
    const gameLoop = () => {
      if (!isDead) {
        player.update(keys)
        checkCollisions()
        cameraX = Math.max(0, player.x - canvas.width/2)
        cameraX = Math.min(cameraX, LEVEL_END_X - canvas.width)
      }

      // Rendering
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      ctx.save()
      ctx.translate(-cameraX, 0)

      // Draw platforms
      ctx.fillStyle = 'green'
      blocks.forEach(p => ctx.fillRect(p.x, p.y, p.width, p.height))

      // Draw enemies
      ctx.fillStyle = 'red'
      enemies.forEach(e => ctx.fillRect(e.x, e.y, e.width, e.height))

      // Draw player
      ctx.fillStyle = 'black'
      ctx.fillRect(player.x, player.y, player.width, player.height)

      ctx.restore()
      requestAnimationFrame(gameLoop)
    }

    // Event listeners
    const keys = {}
    window.addEventListener('keydown', e => { keys[e.code] = true })
    window.addEventListener('keyup', e => { keys[e.code] = false })
    window.addEventListener('resize', () => {
      resizeCanvas()
      initializeGame()
    })

    document.getElementById('restartButton').addEventListener('click', () => {
      initializeGame()
      document.getElementById('overlay').style.display = 'none'
    })

    // Start game
    resizeCanvas()
    initializeGame()
    gameLoop()
  </script>
</body>
</html>
